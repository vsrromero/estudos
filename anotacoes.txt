
|--------------------------------------------------------------------------
| Definições
|--------------------------------------------------------------------------


* Controllers são classes

* Funções - nas classes se chamam métodos, nos controllers se chamam actions



|--------------------------------------------------------------------------
| Para criar um projeto novo no laravel usando console
|--------------------------------------------------------------------------



* Acessar via console a pasta que deseja que o projeto seja criado.

* Digitar composer create-project --prefer-dist laravel/laravel nome_do_projeto "versão do laravel".
    Vale lembrar que o nome do projeto será a pasta que o comando irá criar;



|--------------------------------------------------------------------------
| Para iniciar esse projeto
|--------------------------------------------------------------------------

* acessar a pasta public que foi criada

* executar o comando php -S uri/url:porta

    php -S localhost:8000


* quando quiser rodar esse projeto php artisan serve --port=8082 ou porta desejada


|--------------------------------------------------------------------------
| Para criar um controller usando artisan
|--------------------------------------------------------------------------


php artisan make:controller NomeController

Obs.: como boa prática deve-se criar o nome do controller com a primeira letra maiúscula + palavra Controller
Ex.: php artisan make:controller TesteController


|--------------------------------------------------------------------------
| Trabalhando com views
|--------------------------------------------------------------------------


As views são os arquivos html ou php

Para criar uma view é necessário criá-las na pasta resources/views

os arquivos precisam ser criados da seguinte forma: nomeDoArquivo.blade.php - quando digita .blade.php você identifica para o laravel que esta é uma view

no controller cria-se uma action retornando essa view:

    public function actionName(){
        return view('path.file')
    }

    * exemplo para retornar a view index que está localizada dentro da pasta website na pasta view:

    public function actionName(){
        return view('website.index')
    }


    * note que não é necessário escrever .blade.php uma vez que o método view nativo do Laravel reconhece as views pelos nomes criadas no local correto especificado acima.



|--------------------------------------------------------------------------
| Passando parâmetros nas rotas / parâmetros obrigatórios e opcionais
|--------------------------------------------------------------------------

Para definir uma rota como uma rota que aceita parâmentro basta colocar {parâmetro} na rota indicada e definir a variável



exemplo contact/parametro1/parametro2, neste caso os parâmetros serão obrigatórios, se passar somente um parâmetro retorna um erro, ou seja, ou passa-se os dois ou nenhum.

para um parâmetro ser opcional basta colocar uma? no final de um parâmetro, vamos supor uma rota que tenha dois parâmetros

Route::get('/contact/{name}/{message?}', function($name, $message)
{
    echo "$name . $message";
}

);

o primeiro parâmetro é obrigatório e o segundo é opicional


|--------------------------------------------------------------------------
| Agrupando rotas
|--------------------------------------------------------------------------


Para agrupar rotas é necessário escolher um prefixo ao qual elas ficarão agrupadas

Cria-se então uma rota usando no lugar do verbo http o método prefix;
Route::prefix

Então escolhe-se a string que será o prefixo e depois chamando o método 'group', passa-se uma function() com as rotas dentro.

Ex.:


Route::prefix('/app')->group(function(){

    Route::get('/clients', [ClientsController::class, 'clients']);
    Route::get('/suppliers', [SuppliersController::class, 'suppliers']);
    Route::get('/products', [ProductsController::class, 'products']);

});


|--------------------------------------------------------------------------
| Nomeando uma rota
|--------------------------------------------------------------------------

basta usar o método 'name' após a rota e atribuir um nome.

Ex.: Route::get('/contact', [ContactController::class, 'contact'])->name('web.contact');

A vantagem é que agora podemos alterar qualquer informação da rota sem ter que ficar trocando referências, uma vez que métodos e outras referências serão feitas através do nome da rota.

Por exemplo, nos links agora não se passa mais a referência da rota como por exemplo /contact e sim o nome da rota dentro da função route('nome.da.rota').

Ex.: <a href="{{route('web.contact')}}">

Caso mudemos a rota de /contact para /talktous não será necessário alterar todos os links, uma vez que agora eles se referenciam através do nome da rota, que é web.contact

Note que é necessário usar {{  }} para usar função laravel dentro do html;


|--------------------------------------------------------------------------
| Usando layouts
|--------------------------------------------------------------------------

@extends

É usado quando a necessidade é captar o recuso de um layout para a view

O comando extends recebe o path/caminh de onde o layout está.

No caso deste projeto todo o esqueleto html (html-head-body) está em um layout chamado htmlBody.blade.php, desta forma precisamos que as págians extendam as informações até este escopo, então usando a função @extends('path') indicamos que estamos extendendo nosso conteúdo até esse layout.

Precisa-se então criar uma sessão do conteúdo que será enviado para o layout desejado, para fazer isso usa-se a função @section('nome.da.sessão') e @endsection

Supondo então que temos o seguinte conteúdo para ser passado para o layout do esqueleto html

<div>
    <h1>Conteúdo da página</h1>
    <ul>
        <li>Item 1</li>
        <li>Item 2</li>
    </ul>
</div>

com as tags @section informamos qual sessão deve ser enviada ao layout e no layout usamos a função @yield('nomeDaSection') para receber essa sessão

@section('conteudoDoBody')

<div>
    <h1>Conteúdo da página</h1>
    <ul>
        <li>Item 1</li>
        <li>Item 2</li>
    </ul>
</div>

@endsection

e no layout usa-se a função @yield dentro das tags <body></body>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    @yield('conteudoDoBody')
</body>
</html>


**Para passar um valor dinâmico para um @yield basta criar uma section informando para quase section vai com o valor apropriado

No exemplo acima todas as págians estão recebendo como título o valor Document, para resolver isso basta em cada página que for criando criar a section com o parâmetro

No arquivo de layout aplica-se então o @yield

No layout:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>@yield('title')</title>

Na página

@section('title' , 'Título da página')


**Para incluir um block feito em outro arquivo, por exemplo um menu que aparece em várias páginas, em um arquivo, basta usar @include('path.arquivo')

Ex.:

Temos o seguinte menu salvo em um arquivo chamado navbar.blade.php: //LEMBRANDO: os arquivos blades precisam todos estarem salvos como nome.blade.php

<nav>
<ul>
    <li><a href="{{ route('common.index') }}">Main</a></li>
    <li><a href="{{ route('common.aboutUs') }}">About us</a></li>
    <li><a href="{{ route('common.contact') }}">Contact</a></li>
    <li><a href="{{ route('common.login') }}">Sign in</a></li>
</ul>
</nav>

Para incluir este mesmo menu em diversas páginas, basta usar o comoando include no local da página que programaria este menu

@include('layouts.navbarCommon')

Obs.: no laravel para definir o caminho de um arquivo usa-se "." ao invés de "/"


|--------------------------------------------------------------------------
| Trabalhando com método post
|--------------------------------------------------------------------------


Criar a rota com método post no arquivo de rotas web.php

Route::post('/contact', [ContactController::class, 'contact'])->name('common.contact');
**pode ter o mesmo name e chamar a mesma action, uma vez que o método é diferente o Laravel já interpreta isso

Inserir no formulário dentro da view a instrução @csrf


|--------------------------------------------------------------------------
| MODELS e MIGRATIONS
|--------------------------------------------------------------------------

Para criar um model ou migration.

php artisan make:model ou make:migration

caso queira criar uma migration automaticamente inserir a instrução -m ao final do comando, ex.: php artisan make:model Produto -m

Models são criados com nomes no plural e migragions com nome no singular

    | manipulando SGBD através das Migrations |

Para incluir usa-se o método up e para excluir usa-se o método down

criando:
--------
    usa-se o método up();

    Schema::create('nome_tabela', function (Blueprint $table) {
        $table->id();
        $table->integer*('nome_coluna');
    });

    as colunas que serão inclusas são descritas dentro dos *métodos que são expressos pelas tipagens de dados* $table: $table->integer('estoque');

    após criar todos as colunas que deseja basta executar o comando php artisan migrate

incluindo novas colunas:
------------------------
    usa-se o método up();

    Cria-se uma nova migration (não é necessário criar o model)

    no método up, ao invés de usar Schema::create usa-se Schema::table

    Schema::table('nome_tabela' function (Blueprint $table){
        $table->integer*('nome_coluna');
    });

    *método expresso pele tipagem de dados*


apagando tabelas e colunas:
---------------------------
    usa-se o método down()

    Para apagar colunas precisa alterar a tabela, para isso não se usa o método create e sim o método drop / dropIfExists

    Schemma::dropIfExists('nome_tabela'); //dropa a tabela
    ou
    Schemma::dropIfExists('nome_tabela' , ['nome_coluna']); //dropa a coluna da tabela


criando relacionamento com chave estrangeira:
---------------------------------------------

A chave que o laravel cria não é int, é bigInt somente valores positivos (unsigned)

Na hora que for criar a chave estrangeira na tabela então usa-se:

De 1 para 1:

Schema::create('nome_tabela', function (Blueprint $table) {
    $table->id();
    $table->unsignedBigInteger('nome_coluna*');


    //relationship constraint-foreign key
    $table->foreign(nome_coluna_nessa_tabela_recebera_chave_estrangeira*')->references('coluna_tabela_pai_contendo_id')->on('nome_tabela_com_a_coluna');
    $table->unique('nome_coluna'); //unique define que o relacionamento será de 1 para 1
});

Exemplo atual

Schema::create('product_details', function (Blueprint $table) {
    $table->id();
    $table->unsignedBigInteger('product_id');

$table->foreign('product_id')->references('id')->on('products');
$table->unique('product_id');
});

*// por convenção usa-se o nome da tabela que guarda a chave primária _ nome da colua Ex.: na tabela produto quero a coluna id que é aonde está a chave primária


De 1 para n

segue o mesmo que de 1 para 1 porém se omite o método unique

De n para na

Cria-se uma tabela auxiliar para armazenar as FK
